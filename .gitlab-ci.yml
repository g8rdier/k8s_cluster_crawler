collect_data:
  stage: build
  image: registry.cloud.fits/devops-services/toolchain/docker-go:v0.6.0
  timeout: 60m
  variables:
    GIT_SSL_NO_VERIFY: "true"
  script:
    # Display OS information
    - echo "Displaying OS information"
    - cat /etc/os-release || lsb_release -a || uname -a

    # Update package lists and install dependencies
    - apt-get update && apt-get install -y curl jq python3 python3-pip git || { echo "Error installing dependencies"; exit 1; }

    # Retry logic for kubectl download with retries, delay, timeout, and file size check
    - |
      KUBECTL_RETRIES=5
      KUBECTL_DOWNLOAD_SUCCESS=false
      KUBECTL_VERSION="v1.28.0"
      KUBECTL_EXPECTED_SIZE=49836544  # Correct file size in bytes

      for ((i=1; i<=KUBECTL_RETRIES; i++)); do
        echo "Download attempt $i of $KUBECTL_RETRIES..."
        if timeout 300 curl -LO "https://dl.k8s.io/release/${KUBECTL_VERSION}/bin/linux/amd64/kubectl"; then
          if [ $(stat -c%s "kubectl") -ge $KUBECTL_EXPECTED_SIZE ]; then
            echo "kubectl download succeeded on attempt $i and verified file size."
            KUBECTL_DOWNLOAD_SUCCESS=true
            break
          else
            echo "kubectl download incomplete (wrong file size), retrying..."
            rm -f kubectl
          fi
        else
          echo "kubectl download failed on attempt $i. Retrying..."
          sleep 10
        fi
      done

      # Check if download succeeded
      if [ "$KUBECTL_DOWNLOAD_SUCCESS" = false ]; then
        echo "kubectl download failed after $KUBECTL_RETRIES attempts."
        exit 1
      fi

    # Make kubectl executable and move to bin
    - chmod +x kubectl
    - mv kubectl /usr/local/bin/kubectl || { echo "Error moving kubectl to /usr/local/bin"; exit 1; }

    # Verify kubectl installation
    - kubectl version --client || { echo "kubectl installation verification failed"; exit 1; }


    # Install Python dependencies
    - echo "Installing Python dependencies"
    - pip3 install --no-cache-dir tabulate || { echo "Error installing Python dependencies"; exit 1; }

    # Create a temporary directory for kubeconfig files
    - echo "Creating directory for kubeconfig files"
    - mkdir -p /tmp/kubeconfigs || { echo "Error creating kubeconfigs directory"; exit 1; }

    # Check if kubeconfig variables are set with logging
    - |
      echo "Checking if kubeconfig variables are set"
      for var in ftctl_pf01_kubeconfig ftctl_ps01_kubeconfig fttc_pdf01_kubeconfig fttc_pds01_kubeconfig fttc_tdf01_kubeconfig fttc_tds01_kubeconfig fttc_tf01_kubeconfig fttc_ts01_kubeconfig; do
        echo "Checking variable: $var"
        if [ -z "${!var}" ]; then
          echo "Variable $var is NOT set or is empty"
        else
          echo "Variable $var is set to: ${!var}"
        fi
      done

      # Write each kubeconfig variable to a file without logging sensitive data
    - echo "Writing kubeconfig variables to files"
    - echo "$ftctl_pf01_kubeconfig" | base64 --decode > /tmp/kubeconfigs/ftctl_pf01_kubeconfig || { echo "Error decoding kubeconfig ftctl_pf01"; exit 1; }
    - echo "$ftctl_ps01_kubeconfig" | base64 --decode > /tmp/kubeconfigs/ftctl_ps01_kubeconfig || { echo "Error decoding kubeconfig ftctl_ps01"; exit 1; }
    - echo "$fttc_pdf01_kubeconfig" | base64 --decode > /tmp/kubeconfigs/fttc_pdf01_kubeconfig || { echo "Error decoding kubeconfig fttc_pdf01"; exit 1; }
    - echo "$fttc_pds01_kubeconfig" | base64 --decode > /tmp/kubeconfigs/fttc_pds01_kubeconfig || { echo "Error decoding kubeconfig fttc_pds01"; exit 1; }
    - echo "$fttc_tf01_kubeconfig" | base64 --decode > /tmp/kubeconfigs/fttc_tf01_kubeconfig || { echo "Error decoding kubeconfig fttc_tf01"; exit 1; }
    - echo "$fttc_ts01_kubeconfig" | base64 --decode > /tmp/kubeconfigs/fttc_ts01_kubeconfig || { echo "Error decoding kubeconfig fttc_ts01"; exit 1; }
    - echo "$fttc_tdf01_kubeconfig" | base64 --decode > /tmp/kubeconfigs/fttc_tdf01_kubeconfig || { echo "Error decoding kubeconfig fttc_tdf01"; exit 1; }
    - echo "$fttc_tds01_kubeconfig" | base64 --decode > /tmp/kubeconfigs/fttc_tds01_kubeconfig || { echo "Error decoding kubeconfig fttc_tds01"; exit 1; }

    # Secure the kubeconfig files
    - echo "Securing kubeconfig files"
    - chmod 600 /tmp/kubeconfigs/* || { echo "Error securing kubeconfig files"; exit 1; }

    # Verify the contents of kubeconfig files
    - echo "Verifying the contents of kubeconfig files"
    - for file in /tmp/kubeconfigs/*; do
        echo "Contents of $file:";
        head -n 5 "$file" || { echo "Error reading file $file"; exit 1; }
      done

    # Verify kubeconfig files exist before merging
    - echo "Verifying kubeconfig files exist before merging"
      for file in /tmp/kubeconfigs/*; do
        if [ ! -f "$file" ]; then
            echo "Error: $file does not exist"
            exit 1
        else
            echo "Verified existence of $file"
        fi
      done

    # Merge the kubeconfig files
    - echo "Merging the kubeconfig files"
    - export KUBECONFIG=$(ls -1 /tmp/kubeconfigs/* | tr '\n' ':') || { echo "Error merging kubeconfigs"; exit 1; }
    - kubectl config view --flatten > /tmp/merged_kubeconfig || { echo "Error flattening kubeconfig"; exit 1; }

    # Use the merged kubeconfig
    - echo "Using the merged kubeconfig"
    - export KUBECONFIG=/tmp/merged_kubeconfig

    # Verify the contexts in the merged kubeconfig
    - echo "Verifying the contexts in merged kubeconfig"
    - kubectl config get-contexts || { echo "Error getting contexts"; exit 1; }

    # Ensure scripts are executable
    - echo "Ensuring scripts are executable"
    - chmod +x scripts/cluster_crawler.sh
    - chmod +x scripts/parser.py

    # Run the cluster crawler script
    - echo "Running cluster crawler script"
    - ./scripts/cluster_crawler.sh || { echo "Cluster crawler script failed"; exit 1; }

    # Clean up temporary files
    - echo "Cleaning up temporary files"
    - rm -rf /tmp/kubeconfigs || { echo "Error cleaning kubeconfigs"; exit 1; }
    - rm -f /tmp/merged_kubeconfig || { echo "Error cleaning merged kubeconfig"; exit 1; }
